# solidity


Chaineye  solidity 面试题汇集，供想要学习的小伙伴学习。

推特：@seek_web3

Chainey 社群： 官网 chaineye.info | Chaineye Rust 教程 | 微信: LGZAXE, 加微信之后拉各社群 

所有代码和教程开源在github: https://github.com/0xchaineye/chaineye-blockchain-interview

----------------------------------------------------------------------------------------------------------------------------------------------------------


## 1. 在实际生产中，如果想要保证测试网和主网的合约地址一致，应当怎么做

方案一：合约地址是由 nonce 和 address 决定的，所以只要保证 nonce 和 address 一样即可.
```
new_address = hash(sender, nonce)
```
方案二：使用 create2, 该操作码背后的整体思想是使结果地址独立于未来事件。无论区块链上发生什么，总是可以将合约部署在预先计算的地址上。

新地址是以下函数的函数：

0xFF，一个防止与碰撞的常数CREATE

发件人自己的地址

盐（发送者提供的任意值）

待部署合约的字节码

```
new_address = hash(0xFF, sender, salt, bytecode)
```
CREATE2保证如果使用和提供的sender进行部署，它将存储在.bytecodeCREATE2saltnew_address

因为bytecode包含在此计算中，所以其他代理可以依赖这样一个事实：如果合约曾经部署到 new_address，那么它将是他们所知道的。这是反事实部署背后的关键概念。

## 2.solidity智能合约的 pure 与 view 使用原理及场景

### pure 与 view 原理

pure：不读取更不修改区块上的变量，使用本机的CPU资源计算我们的函数。所以不消耗任何的资源这是很容易的理解的。

view: 但是 view 既然要读取区块链上的值，为什么也不用消耗 gas 呢？

其实很简单，因为作为一个全节点来说，会同步保存所有的信息，保存在本地中。

那么我们要查看区块链上的资源，同样可以直接在一个全节点之上查询数据即可。

我不需要全世界的节点都知道。都去同时的处理这笔事务。我也不需要将调用这笔函数的信息记录在区块链上。

所以 view 仍然不消耗 gas。

view: 可以自由调用，因为它只是“查看”区块链的状态而不改变它

pure: 也可以自由调用，既不读取也不写入区块链


## 3. 如何将固定字节数组转动态字节数组

要将固定长度的字节数组转换为动态长度的字节数组，需要首先创建动态数组，并挨个赋值。

```
pragma solidity ^0.4.23;

contract  fixTodynamic{
      bytes6 name =  0x6a6f6e736f6e;

    function  Todynamic() view public returns(bytes){
        //return bytes(name);
        bytes memory newName = new bytes(name.length);

        //for循环挨个赋值
        for(uint i = 0;i<name.length;i++){
           newName[i] =  name[i];
        }
        return newName;
    }
}
```

### 3. 简单说明智能合约的构造函数和初始化函数的特性与区别

构造函数是特殊的函数，在部署合约的时候，就会被调用。而且只能够在此时被调用。常常用于对于某一些状态变量的初始化。
初始化函数是对对合约进行初始化，只能被调用一层

### 4. 在 Solidity 中，public、private、internal 和 external 都是用来控制合约中函数和变量的访问级别和可见性的关键字。

- public
public 是 Solidity 中默认的访问级别修饰符，表示该函数或变量对所有人可见和可调用。在合约内部或外部都可以访问和调用。使用 public 修饰的函数或变量，会自动生成一个公共的 getter 函数，用于获取变量的值。

- private
private 是 Solidity 中用来限制函数或变量只能在当前合约内部访问的修饰符。使用 private 修饰的函数或变量，不能被合约外部的其他合约或者外部账户访问或调用。

- internal
internal 是 Solidity 中用来限制函数或变量只能在当前合约和其子合约内部访问的修饰符。使用 internal 修饰的函数或变量，不能被合约外部的其他合约或者外部账户访问或调用。

- external
external 是 Solidity 中用来限制函数只能被合约外部的账户访问和调用的修饰符。使用 external 修饰的函数，不能在合约内部被访问和调用，只能在合约外部被调用。


### 4. 智能合约合约继承与可见性

继承是面向对象语言的重要特征。继承是为了模拟现实中的现象，并且可以简化代码的书写。例如猫与够都属于动物。他们都继承动物的某些特征。
合约的继承语法

```
contract  合约名  is  父类合约名{

}
```

- 继承与可见性

状态变量默认是public的类型，可以被继承，可以在外部与内部被调用, 函数默认为public属性,可以被继承，可以在外部与内部被调用

internal: 当为状态变量添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。当为函数添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。

external: 状态变量没有external属性，但是函数有。当为函数加上external属性后，意味着合约只能够在外部被调用，不能够在内部被调用。不能被继承。



### 5. 简单说明 solidity 中 storage、memory 和 calldata 区别与联系

存储位置：storage 和 memory 都是用于存储数据的位置，而 calldata 只是用于在函数调用中传递数据的位置。

生命周期：storage 中的变量在函数调用结束后仍然存在于合约存储器中，而 memory 中的变量在函数调用结束时被删除，calldata 中的数据也在函数调用结束时被删除。

访问：storage 和 memory 中的变量可以进行读取和写入操作，而calldata中的数据只能读取，不能修改。

费用：使用 storage 操作 比memory 更昂贵，因为它需要写入永久存储器，并且会产生永久的状态更改。而 memory 操作相对便宜，因为它只是在临时存储器中分配和读取数据。对于calldata，只能读取，不需要支付任何费用。

类型：在 storage 和 memory 中，可以存储任何 Solidity 类型的数据，包括结构体和数组。但是，在calldata中，只能传递固定大小的原始类型数据。

总体来说，storage 和 memory 用于存储变量，而 calldata 用于传递函数参数。存储位置、生命周期、访问和费用等方面的差异决定了它们在使用中的不同。


### 6. 你是用过哪些种类的合约升级方式，你是怎么操作他们的，升级过程中需要注意哪些事项？

创建新合约并迁移数据：这种方法需要编写新的合约代码，并将旧合约中的数据迁移到新合约中。这种方式需要确保数据的正确迁移，并且需要将旧合约地址作为参数传递给新合约，以便其他合约和用户可以找到新合约。

使用库合约：这种方式可以通过将合约的逻辑与数据分离来进行升级。新的逻辑可以放在一个新的库合约中，并且可以将新的库合约地址设置为旧合约的一个新变量。这样，新逻辑就可以被调用，而数据不需要迁移。

使用代理合约：这种方式也称为升级合约模式。旧合约被称为代理合约，它只包含一些基本的逻辑，如转发交易和调用新合约。新合约则包含更复杂的逻辑。在这种方式中，所有交易都被发送到代理合约，代理合约再将交易转发到新合约进行处理。

在进行合约升级之前，需要确保在升级过程中没有数据丢失或不一致，并且需要考虑安全性问题。操作时需要注意确保权限控制，保护用户资产等安全措施，避免出现意外或者恶意的操作。建议在开发和测试环境中进行合约升级的实验，并使用多重签名等方式确保升级操作的安全性。

升级过程中需要注意 public 变量的存放 slot 位置，，否则会导致数据错乱。


### 7. 常见的智能合约审计工具有哪些，并说明他们之间的区别

智能合约审计工具是一种用于检查智能合约代码安全性和漏洞的软件工具。以下是几种常见的智能合约审计工具：

- Mythril：Mythril是一款基于Python的开源工具，主要用于发现智能合约中可能存在的漏洞。Mythril采用了静态分析的方法，通过对代码的静态扫描来检测漏洞。Mythril支持多种以太坊虚拟机（EVM）及其他区块链的智能合约。

- Oyente：Oyente是一款基于Python的开源工具，用于检查智能合约中可能存在的漏洞。Oyente采用了静态分析的方法，可以检测重入、交易依赖性、迭代器错误等漏洞。

- Securify：Securify是一种基于静态分析的工具，用于检查以太坊智能合约中的漏洞和缺陷。

- SmartCheck：SmartCheck是一款智能合约静态分析和漏洞检测工具，旨在提高智能合约的安全性和可靠性。SmartCheck支持多种虚拟机和智能合约语言，包括Solidity、Vyper、Bamboo等。

- Slither：Slither是一款开源工具，可帮助开发人员和审计人员检测和解决智能合约中的漏洞。Slither采用了静态分析的方法，支持多种虚拟机，可以检测重入、状态可变性、溢出等漏洞。

- Manticore：Manticore是一种动态二进制分析工具，可用于分析以太坊智能合约中的漏洞和安全性。

- Echidna：Echidna是一种基于符号执行的工具，可用于检查以太坊智能合约中的漏洞和安全性。

- Teether：Teether是一个基于二进制分析的工具，用于检查以太坊智能合约的漏洞和缺陷。

以上是一些常见的智能合约审计工具，这些工具可以帮助开发人员和审计人员发现并修复智能合约中的安全漏洞和缺陷。

### 8. 合约攻击相关的

参考教程: [点击查看](https://www.wenwoha.com/17/course_detail)

### 9. 你知道的合约集成编译工具有哪些，并简要说明他们的区别？

hardhat, foundry, remix和truffle

Hardhat：是一个基于 Node.js 的开发环境，提供了丰富的插件和功能，支持编写、测试和部署以太坊智能合约。它还支持与其他工具的集成，如 Remix 和 Truffle。

Foundry：是一个开发人员平台，用于构建、部署和管理以太坊智能合约。Foundry 提供了一种简单的方法来编写智能合约并将其部署到以太坊网络上。

Remix：是一个基于 Web 的 IDE，用于编写、测试和部署以太坊智能合约。它提供了一个直观的用户界面，可以轻松地创建、编辑和调试智能合约。

Truffle：是一个基于 Node.js 的开发框架，提供了一组工具和库，用于编写、测试和部署以太坊智能合约。Truffle 还提供了一个交互式控制台，可以与以太坊网络进行交互，以及支持与其他工具的集成，如 Ganache。

### 10. 简要说明 ERC721 和 ERC 1155 的区别

ERC721和ERC1155都是以太坊上的智能合约标准，用于定义不同类型的数字资产和代币。ERC721标准最初用于定义不可替代代币（Non-Fungible Token，NFT），而ERC1155标准则用于定义可替代和不可替代代币。

ERC721代币是唯一的、不可替代的，每个代币都有其自己的标识符和属性，这使得它们适用于代表数字艺术品、游戏道具等非可替代物品。例如，如果您在以太坊上购买了一张NFT数字艺术品，那么只有您才能拥有这个唯一的代币。

ERC1155代币则是可替代和不可替代的，一个ERC1155代币可以代表一组相同的数字资产，这些资产可以被分割和组合。这使得它们适用于游戏中的道具、虚拟货币等可替代物品。

ERC1155标准与ERC721标准最大的区别是，一个ERC1155合约可以定义多个代币，而ERC721合约只能定义一个。此外，ERC1155代币可以被批量转移，而ERC721代币只能单独转移。

另外，ERC-1159是一种新的标准提案，旨在解决以太坊上代币发行和交易的问题。该标准结合了ERC20和ERC721的优点，可以在同一合约中定义可替代和不可替代的代币，同时还支持代币发行和销毁的燃烧机制。此外，ERC-1159还可以提高代币发行的效率，减少网络拥堵，降低代币交易的成本。



### 11. 简要说明 ERC 1559 作用

ERC-1559是以太坊的一项改进提案，旨在改善以太坊的交易费用机制。当前的以太坊交易费用是由矿工根据交易的竞争情况自由决定的，这可能导致高昂的费用和交易延迟。

ERC-1559提出了一种基于区块空间占用和市场需求的新交易费用机制，其中包括以下要点：

- 每个区块包含的交易数量将被限制在一个预定义的容量范围内，这将导致交易费用的波动性减少。

- 交易费用将由一个算法自动计算，以确保快速确认的交易能够获得更高的优先级。

- 一部分交易费用将被销毁，而不是支付给矿工，这将有助于减少以太坊的通货膨胀。

- 这些改进有望提高以太坊的交易效率，降低交易费用，并减少以太坊的通货膨胀。


### 12. 智能合约钱包中守护恢复是怎么实现的

设置多个地址为守护者，一旦控制合约的 EOA 钱包私钥丢失，就可以由守护者去发起替换合约的 EOA 地址从而达到守护恢复的目的



### 12. 简要说明 EIP4337 作用




### 12. 简要说明 EIP4484 作用


### 14.solidity staticcall 的原理与作用

Solidity的staticcall方法是一种用于在以太坊虚拟机（EVM）上执行不改变状态的外部智能合约的方法。下面是staticcall方法的底层代码实现：

```
function staticcall(
  address target,
  bytes memory data
) internal view returns (bool success, bytes memory returnData) {
  assembly {
    let result := staticcall(gas(), target, add(data, 0x20), mload(data), 0, 0)
    let size := returndatasize()
    returnData := mload(0x40) // allocate new memory
    mstore(0x40, add(returnData, and(add(add(size, 0x20), 0x1f), not(0x1f)))) // round up to nearest 32 bytes
    mstore(returnData, size) // set length of returned data
    returndatacopy(add(returnData, 0x20), 0, size)
    success := and(result, not(iszero(size)))
  }
}
```
这个实现使用了EVM汇编代码。首先，staticcall函数将目标地址和要执行的字节码作为输入参数。然后，它通过使用staticcall指令在EVM上执行外部智能合约。这个指令接受五个参数：gas限制、目标地址、输入数据的起始位置、输入数据的长度和输出数据的起始位置。这个函数没有改变调用者的状态。

在assembly块内，staticcall指令的结果保存在result变量中。然后，returndatasize指令用于获取返回数据的长度。接下来，这个实现通过使用EVM汇编代码来分配新内存、设置返回数据的长度和复制返回数据。最后，它将成功的状态和返回数据作为输出返回给调用者。

总体来说，这个底层实现使用了EVM汇编代码，它使用了一些指令来处理外部智能合约的调用和返回数据的处理，以便实现staticcall方法。

Solidity中的staticcall函数是一种特殊类型的函数调用，它允许在以太坊虚拟机上执行一个不修改状态的智能合约函数。它的作用是查询一个智能合约中的数据或计算某个状态而不会改变区块链上的状态。

在staticcall函数中，虚拟机会创建一个新的临时账户并将调用数据传递给该账户。然后，该账户的代码将被执行，但是无法修改状态或者调用具有状态变更的函数。这个过程不会消耗gas，因为没有状态变更。

staticcall函数的返回值是一个布尔值，用来表示调用是否成功。如果成功，将返回该函数的返回值，否则返回一个空的字节数组。

staticcall的常用场景是从智能合约中读取数据。例如，当需要在一个合约中获取另一个合约的某些数据时，可以使用staticcall函数来查询数据，而不必调用具有状态变更的函数，这样可以避免额外的gas费用和状态变更。


### 15. solidity 中 assembly 原理与作用

Solidity是一种高级编程语言，用于编写智能合约。它基于EVM（以太坊虚拟机）的字节码指令集，但是有时候需要进行更底层的操作，这时候就可以使用Solidity中的Assembly语言。

Assembly是一种低级语言，它直接操作EVM指令集。Solidity中的Assembly可以用来执行一些高级操作，比如内联汇编，也可以用来访问合约存储空间和进行低级别的内存操作。此外，Assembly还可以用于优化代码和执行一些高级加密算法等。

Solidity中的Assembly代码可以通过在函数声明中使用"assembly"关键字来定义。Assembly代码使用一种类似于汇编语言的语法，并使用特定的指令集来操作EVM。Assembly语言还可以直接读写内存和存储器，以及进行其他底层操作。

总之，Solidity中的Assembly可以提供更高级别的操作和更佳的性能，但它也需要更多的编写经验和技能，因为它需要直接操作EVM指令集。对于大多数智能合约，Solidity的高级语言已经足够，不需要使用Assembly。

### 16. 如何避免让合约处于未初始化状态。

攻击者可以接管未初始化的合约。这适用于代理及其实施合同，这可能会影响代理。为了防止使用实现契约，您应该_disableInitializers在构造函数中调用函数以在部署时自动锁定它：

```
/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
    _disableInitializers();
}
```

### 17.智能合约值类型和引用类型有哪些？


### 18.变量，常量，不可变变量区别与联系


### 19.public, private, internal, external 分修饰函数和状态变量的区别


### 20 函数重写和函数重载


### 21 view, pure, payable 和 virtual 修饰符的作用与区别


### 22.函数事件抛出的原则


### 23.父类和子类访问


### 24.构造继承


### 25.抽象合约和接口区别

- 抽象合约：
  - 已实现的函数
  - 未实现的函数（需要由继承的子合约实现）
  -  状态变量。
- 接口: 接口是一种特殊的抽象合约，只包含未实现的函数。
- 接口中不允许：
  - 状态变量
  - 构造函数
  - 已实现的函数
 
### 26.Override 定义，特点和作用


### 27.require， assert 和 revert

- require：用于输入验证和状态检查，失败时返回剩余 gas 并恢复状态。
- assert：用于检测不变量和内部错误，失败时消耗所有剩余 gas 并恢复状态。
- revert：用于显式抛出异常，支持携带错误信息，失败时返回剩余 gas 并恢复状态。

### 28. 状态变量，局部变量和全局变量的定义与特点


### 29.memory, storage， calldata 和 stack 的定义特点


### 30.stack 深度问题


### 31.说一说智能合约的内存布局


### 33.智能合约的值类型和引用类型


### 34.定长数组与动态数组的区别


### 35.常量，变量和不可修改变量的区别


### 36.什么是全局变量，举几个例子


### 37.什么状态变量，状态变量的生命周期


### 38. storage, memory, calldata 区别联系


### 39.合约里面的 Stack 结构，栈深度，栈调用过程中会引发哪些问题


### 40.private, public, external, internal 等修饰符的作用与使用场景


### 41.pure 和 view 修饰的作用与使用场景


### 42.payable 修饰符作用


### 43.Virtual 修饰符作用


### 44.抽象合约，合约 lib 库，合约的 interface 和合约的区别与联系


### 45.谈谈你对 call, delegatecall, staticcall 和 multicall 的理解


### 46.合约内存对齐问题
#### 32.代码题一

V1 版本的合约, 运行很久了

```
contract A {
   uint256 public A;
   uint256 public B;
}
```

V2 版本的合约

```
contract A {
   uint256 public A;
   uint256 public C;   
   uint256 public B;
}
```

- 上面做法是有问题，C 状态变量占用了 B 的 slot
 

#### 32.代码题二

V1 版本的合约, 运行很久了

```
contract A {
 struct AAA {
     uint256 public A;
     uint256 public B;   
  }
  uint256 public Z;
  mapping(uint256=>AAA) ZZZ;
  uint256 public C;
  uint256 public D;
}
```

V2 版本的合约

```
contract A {
 struct AAA {
     uint256 public A;
     uint256 public B;
     uint256 public X;
     uint256 public Y;
  }
  uint256 public Z;
  mapping(uint256=>AAA) ZZZ;
  uint256 public C;
  uint256 public D;
}
```

- 上面做法没有问题

#### 32.代码题二

V1 版本的合约, 运行很久了

```
contract A {
 struct AAA {
     uint256 public A;
     uint256 public B;   
  }
  uint256 public Z;
  AAA ZZZ;
  uint256 public C;
  uint256 public D;
}
```

V2 版本的合约

```
contract A {
 struct AAA {
     uint256 public A;
     uint256 public B;
     uint256 public X;
     uint256 public Y;
  }
  uint256 public Z;
  AAA ZZZ;
  uint256 public C;
  uint256 public D;
}
```


### 47.谈谈你对 address(this), tx.origin 和 msg.sender 的语句解释


### 48.有那些方式可以保证不同网络中的合约地址一致，部署合约的时候怎么玩，create 和 create2 底层实现


### 49.transfer, call 和 send 的区别联系


### 50.合约的升级方式有哪些，详细说明一下他们之间的区别


### 51.怎么理解 ABI，合约，CallData, Bindings 区别联系


### 52.什么是函数选择器？它有哪些使用场景

#============================================================================================================================
# EIP 协议篇
#=============================================================================================================================

### 53.ERC20, ERC721, ERC1155 协议详解


### 54.简述 EIP4844


### 55.简述 ERC4337--AA 钱包


### 56.什么是 EIP-1167 最小代理,举例说明它的应用场景


### 57.EIP4788 作用是什么


### 58.请谈谈你对 ERC-712 和 ERC-2612 的理解， permit 和 permit2


### 59.用于区分不同 EVM 链的是协议是那一个

- EIP155

### 60.简要说明 ERC 1559 作用


### 61.简要说明 ERC 1271 作用

#============================================================================================================================
# 项目篇(桥， LSD， 再质押, Gas Oracle, Price Feed, Fraud proof, Zk Verifier)
#=============================================================================================================================

### 62.描述一下 LSD 产品的业务流程


### 63.简述 Eigenlayer 的架构


### 64.EigenLayer BLS 验签流程描述


### 65.EigenLayer 排队取款的业务流程


### 66.如何设计 Price Feed 项目


### 67.根据你已有的知识来设计一个桥的产品，任意链跨转到任意链


### 68.OpStack 的桥的业务流程


### 67.假设我做 L2, 手续不收 ETH，收我项目方自己发行 token(比方 Metis 收的就是 Metis, Mantle 收的 MNT, x-layer 收的是 OKB)，Gas Oracle 应当怎么做？


