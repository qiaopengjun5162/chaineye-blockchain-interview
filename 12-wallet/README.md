# 区块链钱包面试题目


## 1.描述一下交易钱包的充值和提现流程

### 充值

- 交易所给用户提供地址，用户把钱转进来
- 扫链：获取最新块高，从上一次解析的块开始到最新块高进行交易解析
- 交易解析完之后，如果交易里面 to 是系统用户，则是充值，解析完成之后上账，并通知业务层

### 提现

- 获取需要的签名参数
- 交易离线签名：组织交易，生成待签名消息摘要，将待签名的消息摘要递给签名机进行签名，签名机签名完成之后返回签名串
- 构建完整的交易并发送区块链网络，将签名时计算出来的交易 Hash 或者发送交易时返回交易 Hash 更新到数据库
- 扫链解析到这笔交易，说明提现成功。


## 2.HD 钱包助记词生成的流程

- 第一步：随机熵生成
- 第二步：计算校验和
- 第三步：组合熵和校验和
- 第四步：分割助记词索引
- 第五步：映射为助记词

## 3.助记词的验证过程

- 第一步：检查助记词数量
- 第二步：检查助记词是否在词汇表
- 第三步：将助记词转换成索引
- 第四步：提取种子的校验和
- 第五步：计算校验和
- 第六步：验证校验和


## 4.BIP44 路径

```
m/44'/coin_type'/account'/change/address_index
```

## 5.门限共享秘密拆分过程

秘密-----> n 份，k 份可恢复， 任意 k 份恢复出这个秘密，分别用门限共享算法和逆门限共享秘密算法


## 5.MPC 算法 Keygen 和 Sign 分别需要经过多少轮共识
GG18
- Keygen: 5 轮
- Sign: 9 轮

GG20
- Keygen: 5 轮
- Sign: 7 轮

## 6.为什么 schnorr 比特币手续费可以降低

schnorr 签名聚合成一个签名，还有短密钥，这样签名的数据会比 ECDSA 短很多，所以相对于 ECDSA 签名的交易会便宜很多


## 7. 为什么比特币早期时候不直接用 schnorr 签名算法

因为当时 schnorr 算法在专利期


## 8. 相比较之下 EDDSA 性能，安全性都会高一些，为什么比特币以太坊用了 ECDSA，没有用 EDDSA

- ECDSA 是基于更早的标准（如 FIPS 186-4 和 ANSI X9.62）发展的，因此在密码学界和工业界有较长的使用历史和广泛的标准化支持。它被大量系统和协议（如 TLS 和 Bitcoin）采用，形成了一个庞大的生态系统。
- 虽然 EdDSA 有一些优势，如不容易受到侧信道攻击的影响（如时间攻击和缓存攻击），但 ECDSA 的安全性也已经过广泛的研究和验证。对于很多开发者和企业来说，使用一个已被长期验证的算法是更为保守和安全的选择。
- EdDSA 通常具有更高的签名速度和较快的验证速度，尤其是在大多数软件实现中。然而，对于已经高度优化的 ECDSA 实现，性能差异在许多应用中可能并不明显。
- EdDSA 的设计更为简单且更不易出错，特别是在处理随机数生成等方面。然而，ECDSA 由于使用历史更长，开发者更为熟悉其使用和管理。

## 9.中心化钱包开发里面的充值，提现，归集，转冷，冷转热开发业务流程描述

- 💡💡接口返回的 to 是交易所系统里面的用户地址，这笔交易为充值交易；
- 💡💡接口返回的 from 是交易所系统里面的用户地址，这笔交易为提现交易；
- 💡💡接口返回的 to 是交易所的归集地址，from 是系统的用户地址，这笔交易资金归集交易；
- 💡💡接口返回的 to 地址是冷钱包地址，from 地址时热钱包地址，这笔交易热转冷的交易。
- 💡💡接口返回的 from 地址是冷钱包地址，to 地址时热钱包地址，这笔交易冷转热的交易。

### 充值

- 获得最新块高；更新到数据库
- 从数据库中获取上次解析交易的块高做为起始块高，最新块高为截止块高，如果数据库中没有记录，说明需要从头开始扫，起始块高为 0；
- 解析区块里面的交易，to 地址是系统内部的用户地址，说明用户充值，更新交易到数据库中，将交易的状态设置为待确认。
- 所在块的交易过了确认位，将交易状态更新位充值成功并通知业务层。
- 解析到的充值交易需要在钱包的数据库里面维护 nonce, 当然也可以不维护，签名的时候去链上获取

### 提现

- 获取离线签名需要的参数，给合适的手续费
- 构建未签名的交易消息摘要，将消息摘要递给签名机签名
- 构建完整的交易并进行序列化
- 发送交易到区块链网络
- 扫链获取到交易之后更新交易状态并上报业务层

### 归集

- 将用户地址上的资金转到归集地址，签名流程类似提现
- 发送交易到区块链网络
- 扫链获取到交易之后更新交易状态

### 转冷
- 将热钱包地址上的资金转到冷钱包地址，签名流程类似提现
- 发送交易到区块链网络
- 扫链获取到交易之后更新交易状态

### 冷转热
- 手动操作转账到热钱包地址
- 扫链获取到交易之后更新交易状态


## 10.有用过 rosetta api, 请简单描述起作用，并举几个钱包常用的接口说明

Bitcoin Rosetta API 是由 Coinbase 提出的 Rosetta 标准的一部分，旨在为区块链和钱包提供一个统一的接口标准。这个标准化的接口使得与各种区块链的交互更加容易和一致，无论是对交易数据的读取还是写入。目前已经支持很多链，包含比特币，以太坊等主流链，也包含像 IoTex 和 Oasis 这样的非主流链。

### 用到的接口
/network/list：返回比特币主网和测试网信息。
/network/status：返回当前最新区块、已同步区块高度、区块链处理器的状态等。
/block 和 /block/transaction：返回区块和交易的详细信息，包括交易的输入输出、金额、地址等。
/account/balance：通过查询比特币节点，返回指定地址的余额。

### 发送交易到区块链网络
/construction/submit：通过比特币节点提交签名后的交易。


## 11.ETH2.0 的 epoch, slot 和 block 简述

### Slot（时隙）
定义：Slot 是以太坊2.0中最基本的时间单位，每个slot都有一个指定的时间长度。在每个 slot 中，可能会有一个区块被提议并添加到链中。
时间长度：一个 slot 的长度为 12 秒。这意味着每 12 秒会有一个新的 slot。
功能：在每个 slot 中，网络中的验证者将有机会提议一个新的区块。这些提议者是通过权益证明（PoS）随机选择的。

### Epoch（纪元）
定义：Epoch 是由多个连续的slot组成的更长时间段。在 Eth2.0 中，Epoch 用于管理和组织验证者的活动。
组成：一个 Epoch 由 32 个 slot 组成。
时间长度：由于一个 slot 是12秒，一个 Epoch 的总长度是 384 秒（即6.4分钟）。
功能：Epoch 是用来实现共识机制的一部分。在每个 Epoch 结束时，网络会进行状态和共识的检查和调整，包括对验证者的奖励和惩罚。

### Block（区块）
定义：Block 是包含交易和其他相关数据的记录单元。在以太坊2.0中，每个slot可能会有一个区块被提议，但不保证每个 slot 都有区块。
内容：一个区块包含区块头、交易列表、状态根哈希、签名等数据。
创建过程：在每个 slot 开始时，网络会随机选出一个验证者来提议区块。该验证者将创建一个包含新交易和其他必要信息的区块，并广播到网络中。


## 12.中心化钱包开发中为什么需要确认位，您怎么理解这个确认位的

在确认位过了之后交易回滚的难度很大，每条链不一样，根据历史和经验来定，以太坊的话可以参照区块状态来做


## 13.简单描述以太坊交易类型，并说明这个交易类型的作用

- leagcy: 历史遗留交易类型，签名体为 gasLimit 和 gasPrice
- Eip1559: BaseFee 类型
- blob: EIP4844 交易类型


## 14.去中心化和中心化钱包开发中的异同点有哪些？

### 密钥管理方式不同
HD 钱包私钥在本地设备，私钥用户自己控制
交易所钱包中心化服务器(CloadHSM, TEE 等)，私钥项目方控制

### 资金存在方式不同
HD 资金在用户钱包地址
交易所钱包资金在交易所热钱包或者冷钱包里面

### 业务逻辑不一致
中心化钱包：实时不断扫链更新交易数据和状态
HD 钱包：根据用户的操作通过请求接口实现业务逻辑


## 15.发生硬分叉时，做为钱包的开发，您应当怎么去处理这种状况， 以 ETHPOW 和 ETH2.0 分叉这个过程

认可共识比较


## 16.TON 支持合约吗？若支持，请说出其合约开发语言



## 17.比特币的地址有哪些格式，请说明



## 18.描述一些 UTXO 和账户模型的区别

账户模型：
UTXO: 


## 20.解释一下什么是 EVM 同源链，举例说明一下


## 21.ERC721 和 ERC1155 区别与联系


## 22. Cosmos 共识算法是什么



## 23. Cosmos 钱包资金精度



## 24. Cosmos 签名结构中的 account_number 和 seqence 怎么获取




## 25. memo 是什么，在中心化钱包开发中有什么作用，请举例说明那些链带有 Memo, Memo 另一个名字是什么




## 26. 简述 Cosmos 的 Interchain Security 和 IBC Protocol



## 27. cosmos-sdk 的应用场景



## 28. solana 交易签名有有效期说法吗？若有情描述什么场景的签名会出现这种状况，怎么去解决？


### 29. 怎么去检验账号处于 active？


### 30. solana 代币精度


### 31. 什么是 EVM 同源链，EVM 同源链钱包和 Ethereum 钱包开发中有什么区别


### 32. Cosmos 新版本和老版本签名异同点点


### 33. 简要说明 EOS 账户的激活过程


### 34. 和 EOS 同源的有哪些链


### 35. SUI 链的特点



### 36. Tron 签名和 EVM 链的不同点（和 leagcy 交易类型相比较）



### 37.KDA 由多少条链组成，账户这些链之后有关联吗



### 38.KDA 跨链转账的流程描述



### 39.KDA 共识算法独立吗？矿工奖励有关联吗




### 40.ERC721 和 ERC1155 区别



### 41.NFT MINT 流程




### 42.LSD 产品的质押流程（以 lido 为例说明）




### 43. Solana 质押流程




### 44. Tezos 质押流程



### 45.如何计算一笔 BTC 交易的所需要的 gasFee，有什么方案




### 46.如何计算一笔evm交易的所需要的gasfee，有什么方案



### 47.如何处理BTC的交易执行缓慢，有什么方案，分别有什么区别？



### 48.如何处理EVM的交易执行缓慢，有什么方案，分别有什么区别？



### 49.请设计一个合约的多签钱包



### 50.你怎么对接的tee？怎么请求的tee？tee之间是如何相互通讯的？




### 51.mpc密钥的安全性保证



### 52.Solana 代币的特殊性



### 53.aptos代币的特殊性



### 54.椭圆曲线算法底层实现，以及rsv是什么？分别介绍一下




### 55.ecdsa 和 eddsa 区别



### 56.签名机有支持HD钱包方式吗？




### 57.签名的安全传输方案



### 58.BTC和ETH签名的全流程



### 59.交易里面如何处理合约充值



### 60.什么是 Bitcoin 交易延展性，隔离见证是如何消除了交易延展性


### 61.solana地址大小写敏感怎么处理，比如你发给A的地址却发到了a的地址，有遇到过吗，怎么处理


### 62. solana没有abi 你怎么处理合约交易


### 63 要统计很多代币合约的热度，交易量，用户排行榜等，这个系统等架构数据库啊，技术选型你怎么设计？


### 64 正常派生和硬化派生的区别与联系


## 65 以太坊RLP序列化时ChainID的处理

- RLP（Recursive Length Prefix）：RLP是以太坊中用于序列化数据结构的编码方式，主要用于编码交易、区块等数据结构。

- ChainID的作用：ChainID用于区分不同的以太坊网络（如主网、测试网等），防止重放攻击（即在一个网络上的交易被复制到另一个网络）。

- ChainID在RLP中的处理：

  - 在以太坊交易中，ChainID是EIP-155引入的，用于签名交易。

  - 在RLP编码中，ChainID会被包含在交易的签名数据中，具体格式为：[nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]。

  - 签名时，ChainID会被编码到签名的v值中，公式为：v = recovery_id + 35 + chainId * 2。

- 总结：ChainID通过RLP编码和签名机制，确保交易只能在特定网络中生效。


## 66 Protobuf序列化之后的二进制结构

- Protobuf（Protocol Buffers）：是一种高效的二进制序列化格式，由Google开发，用于结构化数据的序列化和反序列化。

- 二进制结构：

  - Protobuf使用Tag-Length-Value（TLV）格式编码数据。

  - Tag：由字段编号和数据类型组成，占用1个或多个字节。

  - 字段编号：用于标识字段。

  - 数据类型：标识字段的类型（如Varint、64-bit、Length-delimited等）。

  - Length：对于长度可变的数据类型（如字符串、字节数组），会有一个长度字段。

  - Value：字段的实际值。

- 示例：

  - 对于字段int32 id = 1;，如果id = 42，编码结果为：08 2A。

    - 08：Tag（字段编号1，数据类型Varint）。

    - 2A：Value（42的Varint编码）。

- 总结：Protobuf的二进制结构紧凑高效，适合网络传输和存储。


## 67.Shamir共享秘密的本质和使用流程

Shamir共享秘密的本质和使用流程

- Shamir共享秘密：由Adi Shamir提出，是一种秘密共享方案，将秘密分成多个部分（称为“份额”），只有收集到足够数量的份额才能恢复秘密。

- 本质：

  - 基于多项式插值，将秘密编码为一个多项式的常数项。

  - 生成多个点（份额），只有收集到足够数量的点才能重建多项式并恢复秘密。

使用流程：

- 初始化：

  - 选择一个素数p作为有限域。

  - 选择一个秘密s（常数项）。

  - 生成一个k-1次多项式：f(x) = s + a₁x + a₂x² + ... + aₖ₋₁x^(k-1)。

- 生成份额：

  - 为每个参与者生成一个点(x, f(x))。

- 恢复秘密：

  -  收集至少k个点，使用拉格朗日插值法重建多项式，恢复秘密s。

- 总结：Shamir共享秘密是一种安全的分布式存储方案，适用于密钥管理和多方协作场景。
  

## 68.secp256k1和r1的区别，以及比特币和以太坊为何选择secp256k1

- secp256k1：

  - 椭圆曲线方程：y² = x³ + 7。

  - 特点：高效、计算速度快，适合区块链场景。

  - 使用范围：比特币、以太坊等区块链系统。

- secp256r1（也称为NIST P-256）：

  - 椭圆曲线方程：y² = x³ - 3x + b。

  - 特点：参数由NIST标准化，安全性较高，但计算效率略低于secp256k1。

  - 使用范围：TLS、SSL等传统加密场景。

- 区别：

  - 曲线参数不同：secp256k1的曲线参数简单，secp256r1的参数由NIST定义。

  - 性能：secp256k1在签名和验证速度上更快。

  - 安全性：两者均被认为安全，但secp256k1的简单性使其更受区块链青睐。

- 比特币和以太坊选择secp256k1的原因：
  
  - 效率：secp256k1的计算速度更快，适合区块链的高频交易场景。

  - 透明性：secp256k1的曲线参数简单，避免了NIST可能存在的后门争议。

  - 社区共识：比特币率先采用secp256k1，以太坊为兼容性和一致性也选择该曲线。



